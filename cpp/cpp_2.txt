	Параграф 8.8 unordered_map internals (since c++11)

hash function: Key -> int

Массив размера N, хэш переводит в значения от 0 до N и элемент записывается в массив элементов соответствующих хешу.

Есть std::hash<T>()() - стандартная хеш функция примененная к T

insert
erase - expected O(1) (рандомизированное среднее O(1))
find  

Что делать если несколько элементов с одинаковым ключом попали в один хеш?

Если там такой же ключ то не получилось добавить, тк нельзя хранить два одинаковых.

Иначе есть два метода как можно это делать (разрешение коллизий) :

1) Метод цепочек (так сделано в unordered_map)

В каждой вершине хранится вектор или связный список. 

vector<forward_list<Node>> array;

struct Node {
	pair<const Key, Value> kv;
}

Проходим по forward_list и проверям есть ли такой ключ. Если есть то вставка не удалась
Иначе добавляем в начало.

find просто ищем 

erase - если не нашли то ничего, иначе удаляем


Есть double load_factor() и double max_load_factor() которые показывают, на какой процент он может быть заполнен, и при большем отношении и он вызывает рехеш.

load_factor = N / size()

Все это все еще делается с помощью простых чисел.

Но если делать вектором forward_list'ов, то мы не сможем сделать итераторы, а потому вместо этого нам стоит хранить один большой forward_list а внутри ячеек хранить указатели на нужные позиции в forward_list'е

чтобы проверять что изменился блок, то будет проверять равенство хешей, а чтобы их не вычислять будем хранить их явно в ноде))

Это не быстрее чем хранить второй итератор на конец, но решает некоторые дополнительные наши проблемы.

insert - либо добавим новых бакет в начало списка, либо добавим последним элементов бакета (последнего чтобы имели указатель)

erase - тут надо расплакаться и выбрать один из двух путей. Простой - выбрать не std::forward_list, а просто std::list. 

Но gcc и lvmc решили что это для слабых и сделали иначе, и стали хранить вместо указателя на начало нашего бакета храниит указатель на конец предшествующего. (ну а для начала - fake вершину)

Из за этого немного ломается insert, но это легко пофиксить, просто меняя указатель следующего бакета и добавлении, любо явно смотря хеш первого элемента и меняя у него указатель при добавлении нового bucket'а (плюс того что это наш метод, и мы все знаем)

При удалении же послднего элемента bucket'а нам нужно посмотреть явно на хеш элемента, посмотреть на предыдущую ветку, посмотреть следующего, и поставить ему ответ предыдущую ячейку. (вроде че то такое, но тут немного не уловил)

rehash - по сути последовательный erase и insert (в новый массив) по новой. insert и erase не инвалидируют указатели и ссылки (это надо понять), а значит они не инвалидируются в целом. Даже рехэш не будет этого ломать, ведь это erase и insert, по сути.

Итераторы все таки инвалидируются, потому что (а тут Мещерин не знает почему, и он отвечает что не знает человека который бы знал почему это так. Возможно в России никто не знает почему это так. (можно получить +балл за понимание почему это))

Exception safety.

template <typename Key, typename Value, typename Hash, typename Equal>
class unordered_map {
	
}

Если рехеша не прошло, то все все нормально, и все можно не очень сложно откатить

При рехеше можно не вызывать Hash (ведь мы заранее храним их в ячейке), а также не вызывать Equals (ведь мы можем не рехешить, пока не убедимся что ключи разные)

Конструкторы Key и Value нам трогать не надо, ведь никого перемещать не надо.

Значит по сути ничего делать не надо, и мы уже почти exception_safety (ну почти)

Но в стандарте не гарантируется, что нормально работает при исключениях из Hash и возможно из Equals (можно посмотреть на cppref)

2) Метод открытой адресации 

Есть еще одна функция g, которая ставит каждой ячейки в соответствие другую ячейку.

Теперь при удалении нужно ставить специальный флаг, что она удалена

ну и если у нас совпало, то мы кладем в следующую за ней первую не занятую.

Иногда в таком случае придется делать рехэш (раз в некоторое время менять N и за линейное время перекладывать)

Выбирать новое N стоит брать простым, чтобы цепочки уменьшились и желательно в несколько раз больше (например в 2)

К слову будет задачка std::list. 


		Глава 9. Allocators and memory managmenet

	Параграф 9.1 Idea and basic usage of allocators


Container -> Allocator -> operator new -> malloc -> OS

----------- изучаем это --------------------------------

template <typename T>
struct allocator {
	
	template<typename U>
	allocator(allocator<U>) {}

	T* allocate(size_t count) { // тут нас немного обманывают
		return reinterper_cast<T*>(new char[count * sizeof(T)]);
	}

	void deallocate(T* ptr, size_t) {
		delete[] reinterpret_cast<char*>(ptr);
	}

	template<typename U, typename... Args> // нас продолжают обманывать, но мы будем это исправлять.
	void construct(U* ptr, const Args&... args) {
		new (ptr) U(args...); // да это неправильно
	}
	template<typename U>
	void destroy(U* ptr) {
		ptr->~U();
	}

	template <typename U >
	struct rebind {
		using other = allocator<U>;
	}
};

PoolAllocator - выделяет массив памяти а дальше осуществляет менеджмент памяти сам

StackAllocator - не вызывает new, тк просит массив на вход ( то есть по сути работает с памятью на стеке )

Решение проблем

template <typename T, teypname Alloc = std::allocator<T>>
class list {
	struct BaseNOde {
		BaseNode* prev;
		BaseNode* next;
	};
	struct Node: BaseNode {
		T value;
	};

	BaseNode fakeNode;
	size_t count;
	typename Alloc::rebind<Node>::other alloc;

	list(const Alloc& alloc) fakeNode(), count(), alloc(alloc) {}
}

	Параграф 9.2 Stateful allocators and allocator_traits

FreeListAllocator - при удалении не удаляет явно, а просто кладет в лист пустых нод

Первая задача - написать std::list с кастомным аллокатором. Основная проблема - аллокатор. Нужно будет написать еще и StackAllocator

можно использовать shared_ptr 

можно завести отдельный класс Pool в котором заниматься менеджингом массива Pool, запретив его копировать. Сам аллокатор копируем сколько влезет

короче я не очень понимаю о чем мы говорим

Allocator traits

template <typename Alloc>
struct allocator_traitrs {
	template <typenmae U, typename... Args> 
	void construct (Alloc& alloc, U* ptr, const Args&... args) {
		if constexpr(/* Alloc has mthod construct*/) {
			// надо посмотреть
		}
	}	
};

На этой неделе будет первая задача.

Тесты не пройти если в наших аллокаторах оно должно быть быстрее чем у аллокаторов в стандарте, при этом это не сложно тк это должно быть значительно быстрее)











